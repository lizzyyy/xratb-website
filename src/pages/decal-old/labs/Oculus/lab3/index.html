<!DOCTYPE html><html lang="en-US"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><link rel="stylesheet" href="/decal/assets/css/just-the-docs-default.css"> <script src="/decal/assets/js/just-the-docs.js"></script><meta name="viewport" content="width=device-width, initial-scale=1"><title>Oculus Lab 3: The Monster | Extended Reality Development</title><meta name="generator" content="Jekyll v3.9.3" /><meta property="og:title" content="Oculus Lab 3: The Monster" /><meta property="og:locale" content="en_US" /><meta name="description" content="Extended Reality Development DeCal" /><meta property="og:description" content="Extended Reality Development DeCal" /><link rel="canonical" href="http://localhost:4000/decal/labs/Oculus/lab3/" /><meta property="og:url" content="http://localhost:4000/decal/labs/Oculus/lab3/" /><meta property="og:site_name" content="Extended Reality Development" /><meta property="og:type" content="website" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Oculus Lab 3: The Monster" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","description":"Extended Reality Development DeCal","headline":"Oculus Lab 3: The Monster","url":"http://localhost:4000/decal/labs/Oculus/lab3/"}</script><body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"><title>Link</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"><title>Menu</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"><title>Expand</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"><polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"><title id="svg-external-link-title">(external link)</title><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-copy" viewBox="0 0 16 16"><title>Copy</title><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"><path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/><path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"><title>Copied</title><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"><path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/><path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg><div class="side-bar"><div class="site-header"> <a href="/decal/" class="site-title lh-tight"> Extended Reality Development </a> <a href="#" id="menu-button" class="site-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a></div><nav aria-label="Main" id="site-nav" class="site-nav"><ul class="nav-list"><li class="nav-list-item"><a href="/decal/" class="nav-list-link">Home / Announcements</a><li class="nav-list-item"><a href="#" class="nav-list-expander" aria-label="toggle links in Homework category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/decal/homework/" class="nav-list-link">Homework</a><ul class="nav-list "><li class="nav-list-item "><a href="/decal/homework/hw1/" class="nav-list-link">Homework 1: The Rube Goldberg Ball Machine</a><li class="nav-list-item "><a href="/decal/homework/hw2/" class="nav-list-link">Homework 2: Music Visualizer</a><li class="nav-list-item "><a href="/decal/homework/hw3/" class="nav-list-link">Homework 3: Fractal Generation</a><li class="nav-list-item "><a href="/decal/homework/hw4/" class="nav-list-link">Homework 4: Pong</a><li class="nav-list-item "><a href="/decal/homework/hw5/" class="nav-list-link">Homework 5: Collisions, Raycasting, and Triggers</a></ul><li class="nav-list-item active"><a href="#" class="nav-list-expander" aria-label="toggle links in Labs category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/decal/labs/" class="nav-list-link">Labs</a><ul class="nav-list "><li class="nav-list-item active"><a href="#" class="nav-list-expander" aria-label="toggle links in Oculus category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/decal/labs/Oculus/" class="nav-list-link">Oculus</a><ul class="nav-list"><li class="nav-list-item "> <a href="/decal/labs/Oculus/lab1/" class="nav-list-link">Oculus Lab 1: Building the Environment</a><li class="nav-list-item "> <a href="/decal/labs/Oculus/lab2/" class="nav-list-link">Oculus Lab 2: Building the Gun</a><li class="nav-list-item active"> <a href="/decal/labs/Oculus/lab3/" class="nav-list-link active">Oculus Lab 3: The Monster</a><li class="nav-list-item "> <a href="/decal/labs/Oculus/lab4/" class="nav-list-link">Oculus Lab 4: Putting It All Together</a></ul><li class="nav-list-item "><a href="#" class="nav-list-expander" aria-label="toggle links in AR Foundation category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/decal/labs/AR%20Foundation/" class="nav-list-link">AR Foundation</a><ul class="nav-list"><li class="nav-list-item "> <a href="/decal/labs/AR%20Foundation/lab1/" class="nav-list-link">AR Foundation Lab 1: Project Setup / Building the Environment</a><li class="nav-list-item "> <a href="/decal/labs/AR%20Foundation/lab2/" class="nav-list-link">AR Foundation Lab 2: Building the Gun</a><li class="nav-list-item "> <a href="/decal/labs/AR%20Foundation/lab3/" class="nav-list-link">AR Foundation Lab 3: The Monster</a><li class="nav-list-item "> <a href="/decal/labs/AR%20Foundation/lab4/" class="nav-list-link">AR Foundation Lab 4: Putting It All Together</a><li class="nav-list-item "> <a href="/decal/labs/AR%20Foundation/lab5/" class="nav-list-link">AR Foundation Lab 5: Image Tracking, Health Bar</a></ul><li class="nav-list-item "><a href="#" class="nav-list-expander" aria-label="toggle links in HTC Vive category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/decal/labs/HTC%20Vive/" class="nav-list-link">HTC Vive</a><ul class="nav-list"><li class="nav-list-item "> <a href="/decal/labs/HTC%20Vive/lab1/" class="nav-list-link">Vive Lab 1: Building the Environment</a><li class="nav-list-item "> <a href="/decal/labs/HTC%20Vive/lab2/" class="nav-list-link">Vive Lab 2: Creating the Gun</a><li class="nav-list-item "> <a href="/decal/labs/HTC%20Vive/lab3/" class="nav-list-link">Vive Lab 3: The Monster</a><li class="nav-list-item "> <a href="/decal/labs/HTC%20Vive/lab4/" class="nav-list-link">Vive Lab 4: Putting It All Together</a></ul></ul><li class="nav-list-item"><a href="/decal/lectures/" class="nav-list-link">Lectures</a><li class="nav-list-item"><a href="#" class="nav-list-expander" aria-label="toggle links in Final Project category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/decal/final-project/" class="nav-list-link">Final Project</a><ul class="nav-list "><li class="nav-list-item "><a href="/decal/final-project/project-resources/" class="nav-list-link">Project Resources</a></ul><li class="nav-list-item"><a href="/decal/extra-resources/" class="nav-list-link">Extra Resources</a></ul></nav><footer class="site-footer"> This site uses <a href="https://github.com/just-the-docs/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.</footer></div><div class="main" id="top"><div id="main-header" class="main-header"><div></div></div><div id="main-content-wrap" class="main-content-wrap"><nav aria-label="Breadcrumb" class="breadcrumb-nav"><ol class="breadcrumb-nav-list"><li class="breadcrumb-nav-list-item"><a href="/decal/labs/">Labs</a><li class="breadcrumb-nav-list-item"><a href="/decal/labs/Oculus/">Oculus</a><li class="breadcrumb-nav-list-item"><span>Oculus Lab 3: The Monster</span></ol></nav><div id="main-content" class="main-content" role="main"><h1 class="no_toc" id="oculus-lab-3-the-monster"> <a href="#oculus-lab-3-the-monster" class="anchor-heading" aria-labelledby="oculus-lab-3-the-monster"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Oculus Lab 3: The Monster</h1><h2 class="no_toc text-delta" id="table-of-contents"> <a href="#table-of-contents" class="anchor-heading" aria-labelledby="table-of-contents"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Table of contents</h2><ul id="markdown-toc"><li><a href="#the-monster-prefab" id="markdown-toc-the-monster-prefab">The Monster Prefab</a><li><a href="#creating-the-navmesh" id="markdown-toc-creating-the-navmesh">Creating the Navmesh</a><li><a href="#moving-the-monster" id="markdown-toc-moving-the-monster">Moving the Monster</a><li><a href="#attacking-the-player" id="markdown-toc-attacking-the-player">Attacking the Player</a><li><a href="#shooting-the-monster" id="markdown-toc-shooting-the-monster">Shooting the Monster</a><li><a href="#hurting-the-monster" id="markdown-toc-hurting-the-monster">Hurting the Monster</a><li><a href="#killing-the-monster" id="markdown-toc-killing-the-monster">Killing the Monster</a><li><a href="#check-off" id="markdown-toc-check-off">Check Off</a></ul><hr /><p>In this lab, we’ll focus on the main antagonist of our game: the monster. Before we jump into it, let’s list out all the things that this monster has to do:</p><ul><li><p>Move towards the player while avoiding obstacles.</p><li><p>Attack the player when it’s close enough.</p><li><p>Die after getting shot, then disappear.</p><li><p>Do all of the above with appropriate animations and sounds.</p></ul><p>You can download the skeleton assetpackage <a href="https://drive.google.com/file/d/1FFYEI-ncfnX_9sBzzm0LQKzySGryEHBj/view?usp=sharing"><strong>here</strong></a>.</p><p>After initializing the new project with the skeleton, you will need to install the XR packages again through <strong>Window &gt; Package Manager &gt; (on the top) Packages: Unity Registry</strong>:</p><ul><li>Oculus XR Plugin<li>XR Plugin Management<li>XR Interaction Toolkit</ul><h1 id="the-monster-prefab"> <a href="#the-monster-prefab" class="anchor-heading" aria-labelledby="the-monster-prefab"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> The Monster Prefab</h1><p>Open the provided Lab scene in the assets folder. Within the prefabs folder, we’ve provided a Monster prefab for you already. Go ahead and drag it into the scene and turn it around to face the player.</p><p><img src="/decal/assets/images/oculus/lab3/1_2.png" alt="image" /></p><p>As you’ll notice, the monster gameobject has two children already: hips and mesh_1. mesh_1 contains the mesh renderer that gives it the look it has, while the actual mesh itself is contained in the tree-like structure within hips, which contains the positions of all the bones in our monster’s skeletons (also called the rig).</p><p>We won’t go into the 3D modeling details. If you wish to learn more, UCBUGG is a well-established and fantastically run decal on the subject. We’ll focus instead on how to use this 3D model in our project.</p><h1 id="creating-the-navmesh"> <a href="#creating-the-navmesh" class="anchor-heading" aria-labelledby="creating-the-navmesh"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Creating the Navmesh</h1><p>Moving our monster is a deceptively challenging task when there are obstacles in the way. There are a lot of ways to do it (if you’ve taken CS61B, you’ll remember Dijkstra’s algorithm or A* search, which can be adapted to work in this situation), but actually implementing one would be outside the scope of this course. Luckily, Unity already has a navigation infrastructure in place that we can take advantage of.</p><p>What we’re going to do is build what’s called a navigation mesh, or navmesh for short. A navmesh is a map of the environment that enables supported agents, called navmesh agents, to traverse the environment. By building this map ahead of time, agents won’t have to repeatedly compute where they can and cannot go while the game is running.</p><p><img src="/decal/assets/images/oculus/lab3/2_1.png" alt="image" /></p><p>You can read more about Unity’s navigation system <a href="https://docs.unity3d.com/Manual/Navigation.html">here</a>.</p><p>Next, open up the navigation window via Window &gt; AI &gt; Navigation and click on the “Bake” tab. This tab is where we can “bake” a navmesh into the environment for later use. Navmeshes are built given certain assumptions about the agent traversing it. As you can see in the “Baked Agent Size” section, Unity assumes our agent is a cylinder of certain radius and height.</p><p><img src="/decal/assets/images/oculus/lab3/3_0.png" alt="image" /></p><p>We’ll only change one of these settings: set Agent Radius to 0.4 to better fit our monster. Then hit bake. You should see the map get covered in blue, representing all the traversable parts of the map.</p><p><img src="/decal/assets/images/oculus/lab3/4_0.png" alt="image" /></p><h1 id="moving-the-monster"> <a href="#moving-the-monster" class="anchor-heading" aria-labelledby="moving-the-monster"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Moving the Monster</h1><p>Now that we have a navmesh, let’s turn our monster into a nav mesh agent and move it. Add a “nav mesh agent” component to our monster gameobject. This component interacts with the navmesh and allows whatever object it’s attached to to move intelligently.</p><p>Change Speed to 0.75 (you don’t want the Monsters sprinting at you) and change Stopping Distance to 1.3. This indicates that once the monster gets within Stopping Distance of its target, it’ll stop moving - this will be useful once we incorporate attacks. Next, notice that we’re using the Humanoid agent type. Go to the Agents tab in the navigation window and change Radius to 0.4 to match the radius we used for the navmesh.</p><p>Next, create a new script called “Monster” that we’ll use to control all functionality of the gameobject. Start off by creating and initializing variables for the player, nav mesh agent, and audio source component. Note that in order to utilize the NavMeshAgent class, we’ll have to import UnityEngine.AI.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;

public class Monster : MonoBehaviour {

    public GameObject player;

    private NavMeshAgent navMeshAgent;

    // Use this for initialization
    void Start () {
        navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();
    }
    
    // Update is called once per frame
    void Update () {
        
    }
}
</code></pre></div></div><p>Then to get the monster moving, all we have to do is add this line to Update(), which will repeatedly set the destination of the monster to the player’s location.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void Update () {
    navMeshAgent.SetDestination(player.transform.position);
}
</code></pre></div></div><p>In Unity, add this script to the Monster gameobject. For the player field, drag in Main Camera which can be found under XR Origin &gt; Camera Offset, which represents our headset. Press play, and you should see the monster move towards you.</p><p>It looks a little odd to see our monster power-slide to its destination, so we’re going to add in animation support. Add an Animator component to the Monster. We’ve provided a Controller for you in Assets &gt; Animations &gt; Monster and an Avatar (the mapping between Unity’s normal bone structure and a special one) in Models &gt; Monster &gt; MonsterAvatar. Drag those into their fields.</p><p><img src="/decal/assets/images/oculus/lab3/5.png" alt="image" /></p><p>Take a look at the monster controller in the Animator window. It’s a little more complicated than the gun controller, but not by much. Notice that we start off in the “Walking” state. If you press play now, the monster should walk towards you with a lumbering walk animation.</p><p>Before continuing, we’re going to add in sound support. Add an audio source component to the Monster and disable Play On Awake. Then in Monster.cs, declare/initialize it properly along with three audio clips, which we’ll use throughout the lab. Play the spawnClip in Start() to announce that this Monster has spawned.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private NavMeshAgent navMeshAgent;
private AudioSource audioSource;

public AudioClip spawnClip;
public AudioClip hitClip;
public AudioClip dieClip;

void Start () {
    navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();
    audioSource = GetComponent&lt;AudioSource&gt;();
    audioSource.PlayOneShot(spawnClip);
}
</code></pre></div></div><p>In Unity, you can find and fill in the appropriate clips in Assets &gt; Sounds. The spawnClip is grrr1, hitClip is hit1, and dieClip is (very surprisingly) called die.</p><h1 id="attacking-the-player"> <a href="#attacking-the-player" class="anchor-heading" aria-labelledby="attacking-the-player"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Attacking the Player</h1><p>The next thing we want to do is have the monster begin attacking the player once it gets in range. Looking at the monster controller again, we see that the state transitions from Walking to Attack when the “Attack” bool parameter is set to true. Let’s do just that in our Monster.cs script.</p><p>We’ll need to add a check to make sure we’re in range to attack. First, add a public attackRange variable and set it to 1.3 in the editor. Then add and initialize the animator variable.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class Monster : MonoBehaviour {

    public GameObject player;
    public float attackRange;

    private NavMeshAgent navMeshAgent;
    private AudioSource audioSource;
    private Animator animator;

    ...

    // Use this for initialization
    void Start () {
        navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();
        audioSource = GetComponent&lt;AudioSource&gt;();
        audioSource.PlayOneShot(spawnClip);
        animator = GetComponent&lt;Animator&gt;();
    }

    ...
}
</code></pre></div></div><p>Then in update, compute the distance between the monster and the player. Since we only care about the 2D distance between the two, we’ll zero out the y component before computing the magnitude.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void Update () {
    navMeshAgent.SetDestination(player.transform.position);

    Vector3 distanceVector = transform.position - player.transform.position;
    distanceVector.y = 0;
    float distance = distanceVector.magnitude;
}
</code></pre></div></div><p>Use this distance to check whether or not we should transition into attacking.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void Update () {
    ...
    
    if (distance &lt;= attackRange) {
        animator.SetBool("Attack", true);
    }
}
</code></pre></div></div><p>Save your work and try it in the editor. The monster should walk towards you, then stop some distance away and start hitting you with its fists. Whenever it hits you, an error should also pop up in the console:</p><p><img src="/decal/assets/images/oculus/lab3/6_0.png" alt="image" /></p><p>Unity allows you to hook up <a href="https://docs.unity3d.com/Manual/AnimationEventsOnImportedClips.html">animation events</a> to certain points in time within an animation. These events take in a function name. When the animation plays in-game and reaches that point in time, Unity will look for that function and call it. In this case, there’s an animation event attached to the moment the monster’s fists hit the ground, with function name “Attack”. Since we don’t have a function called “Attack” yet, it raises this error. Stub in the Attack() function to fix this; we’ll just play the hitClip sound for now.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public void Attack() {
    audioSource.PlayOneShot(hitClip);
}
</code></pre></div></div><h1 id="shooting-the-monster"> <a href="#shooting-the-monster" class="anchor-heading" aria-labelledby="shooting-the-monster"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Shooting the Monster</h1><p>Now that the monster can attack us, it’s only fair that we are able to fight back. On a high level, this is the procedure for shooting the monster:</p><ol><li><p>Player shoots gun. Invisible ray comes out of the gun and travels forward.</p><li><p>Ray hits an invisible collider on the monster, which calls a function.</p><li><p>Monster triggers its hurt animation, takes damage.</p><li><p>If monster loses all its health, kill it.</p></ol><p>Start by adding a capsule collider to the monster. Set the radius to 1, the height to 3, the center to y=1.5, and mark it as a trigger so it doesn’t collide with the environment. It should just about encapsulate the monster.</p><p><img src="/decal/assets/images/oculus/lab3/7_0.png" alt="image" /></p><p>Next, switch to editing the Gun.cs script. We’re going to add a raycast check to Fire() to check if we’ve hit a monster. I won’t pretend to be able to explain raycasting better than Unity itself, so before looking at the code below, watch the first minute and a half of <a href="https://unity3d.com/learn/tutorials/topics/physics/raycasting"><strong>this</strong></a> video. <strong>Raycasts can be confusing intuitively, so don’t be afraid to ask for clarification!</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public void Fire() {
    audioSource.PlayOneShot(audioSource.clip);
    particleSystem.Play();

    RaycastHit hit;
    Vector3 origin = particleSystem.transform.position;
    Vector3 direction = particleSystem.transform.right;
    if (Physics.Raycast(origin, direction, out hit, 100f)) {

    }
}
</code></pre></div></div><p>We’re using the position/rotation of MuzzleFlashEffect (the gameobject particleSystem is attached to) for the origin of the raycast since it sits at the front of the gun where the bullet would come out of. The direction is set to its “right” direction because it’s the red arrow (which corresponds to the right direction) that points out of the gun barrel. We’ve defined a hit object to hold any data that comes through, and the ray itself lasts for 100 meters.</p><p>The end result is that this if case returns true only if the fired raycast hit something, with whatever collider it hit stored in the “hit” variable. We’ll now check if that collider belonged to a monster. If it does, we’ll extract the Monster script from it and call an appropriate function.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public void Fire() {
    ...

    if (Physics.Raycast(origin, direction, out hit, 100f)) {
        GameObject hitObject = hit.collider.gameObject;
        if (hitObject.CompareTag("Monster")) {
            print("Hit a monster!");
        }
    }
}
</code></pre></div></div><p>In Unity, assign the “Monster” tag to the monster gameobject, creating it if necessary. Press play, and shoot your gun at the monster. Does it trigger the print message?</p><h1 id="hurting-the-monster"> <a href="#hurting-the-monster" class="anchor-heading" aria-labelledby="hurting-the-monster"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Hurting the Monster</h1><p>Before we start replacing the print message with proper damage-taking interaction, we need to go into details on the monster’s various gameplay states. Our monster can be in one of three states at any given point in time:</p><ol><li><p>ALIVE: In this state, the monster will move towards and attack you.</p><li><p>DYING: In this state, the monster has taken enough damage and is in the midst of doing its death animation. It will no longer move towards you and cannot take further damage.</p><li><p>SINKING: In this state, the monster has finished its death animation and is now sinking through the ground before finally getting removed from the game.</p></ol><p>To implement this in script, we’re going to use C#’s <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum">enum</a> system to list the possible states and a variable to track which state we’re in. Switch to Monster.cs.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class Monster : MonoBehaviour {

    public enum State {
        ALIVE, DYING, SINKING
    }
    
    public State monsterState = State.ALIVE;

    ...

}
</code></pre></div></div><p>Our monster should only be moving around if it’s in the ALIVE state. Encapsulate the code you’ve written in Update() so far in an if block checking for this.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void Update () {
    if (monsterState == State.ALIVE) {
        
    }
}
</code></pre></div></div><p>Next, we’re going to implement the monster’s health. Add a public int maxHealth (set that to 100 in Unity) and private int currHealth to the class. Initialize currHealth properly in Start(). Finally, stub in a public Hurt() function that we’ll be using soon.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public int maxHealth;
private int currHealth;

void Start () {
    ...

    currHealth = maxHealth;
}

...

public void Hurt(int damage) {

}
</code></pre></div></div><p>Now switch back to editing Gun.cs. Add a public int damage, which will represent how much damage each bullet deals to a monster.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public int damage;
</code></pre></div></div><p>Set it to 20 in Unity. Then in the raycast section, remove the print statement. In its place, extract out the monster script from the monster gameobject, and call the Hurt() function with the newly defined damage var as the parameter.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RaycastHit hit;
Vector3 origin = particleSystem.transform.position;
Vector3 direction = particleSystem.transform.right;
if (Physics.Raycast(origin, direction, out hit, 100f)) {
    GameObject hitObject = hit.collider.gameObject;
    if (hitObject.CompareTag("Monster")) {
        Monster monsterScript = hitObject.GetComponent&lt;Monster&gt;();
        monsterScript.Hurt(damage);
    }
}
</code></pre></div></div><p>Switch again to editing Monster.cs so we can fill out the Hurt() function. It’s fairly straightforward: we first check if the monster is still alive, and if so call the proper animation trigger (which you can view in the Monster’s animation controller. We also subtract the damage taken from its current health, and if it dips below 0 we’ll call Die(), which we’ll stub in with a print statement for now.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public void Hurt(int damage) {
    if (monsterState == State.ALIVE) {
        animator.SetTrigger("Hurt");
        currHealth -= damage;
        if (currHealth &lt;= 0)
            Die();
    }
}

void Die() {
    print("Monster died.");
}
</code></pre></div></div><p>Try it out now. You should be able to shoot the Monster and trigger a small stagger animation, and after shooting it five times see the print statement (make sure to set Max Health to 100 in the Monster GameObject’s Monster component).</p><h1 id="killing-the-monster"> <a href="#killing-the-monster" class="anchor-heading" aria-labelledby="killing-the-monster"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Killing the Monster</h1><p>Filling in the Die() function is fairly straightforward:</p><ul><li><p>Set the state appropriately.</p><li><p>Play the dying sound effect (dieClip).</p><li><p>Stop navigating towards the player.</p><li><p>Trigger the appropriate animation.</p><p>void Die() { monsterState = State.DYING; audioSource.PlayOneShot(dieClip); navMeshAgent.isStopped = true; animator.SetTrigger(“Dead”); }</p></ul><p>If you try the game now, you should be able to see all this happen after shooting the monster five times! You should also notice an error message in the console:</p><p><img src="/decal/assets/images/oculus/lab3/8_1.png" alt="image" /></p><p>This is an animation event hooked up to the end of the death animation. If we were to just let the monster sit there forever, the corpses would end up glitching into one another and lagging the game. So we’re now going to use this animation event to make dead monsters sink through the floor and then disappear after dieing. Stub in the public StartSinking() function.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public void StartSinking() {

}
</code></pre></div></div><p>There are a couple things we need to do in this function:</p><ul><li><p>Set the state appropriately.</p><li><p>Disable the navigation component. The nav mesh agent component overrides movement control from other sources, so in order to make our monster sink through script we must disable this component first.</p><li><p>Set the monster to be destroyed after a set amount of time. We’ll use 5 seconds, which should be long enough for the monster to fully move through the floor.</p><p>public void StartSinking() { monsterState = State.SINKING; navMeshAgent.enabled = false; Destroy(gameObject, 5); }</p></ul><p>Next is to make the monster actually sink, which we’ll do in the Update() function. Add a public float sinkSpeed, which will represent how quickly the monster sinks through the ground.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public float sinkSpeed;
</code></pre></div></div><p>Then in Update(), add an else if block for when our monster is in the sinking state. In it, we’ll calculate how far down the monster needs to move this frame and translate it downwards that much. Time.deltaTime returns the time between this frame and the previous.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>else if (monsterState == State.SINKING) {
    float sinkDistance = sinkSpeed * Time.deltaTime;
    transform.Translate(new Vector3(0, -sinkDistance, 0));
}
</code></pre></div></div><p>Set sinkSpeed to 0.15 in Unity, and give it a try! Killing the monster should now make it sink through the floor before disappearing from the scene.</p><h1 id="check-off"> <a href="#check-off" class="anchor-heading" aria-labelledby="check-off"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Check Off</h1><p><em>This is the end of lab 3. To check off, show a facilitator that your monster will do the following:</em></p><ul><li><p><em>Spawn with a sound effect and move towards the player.</em></p><li><p><em>Stop moving when in range and begin attacking the player (with sound effect).</em></p><li><p><em>Stagger when shot by a gun.</em></p><li><p><em>Fall to the ground after taking enough damage (with sound effect) and sink through the floor before getting removed from the scene.</em></p></ul></div></div></div>
